CA01_01

Some of the content for this CA has been discussed using the chat.openai.com website, which can be seen here - https://chat.openai.com/share/2553fff4-333f-44fc-9790-571488e8b20e

-----------------------------------------------------------------------------------------------------------------------------------------------

- abstract class Pet` as compared to just `class Pet`

abstract class Pet{ 

	String name;
	...
	...
	}
	Pet p1 = new Pet(); 					// Compile Error - Cannot instantiate an abstract class
	
class Pet(){
	
	String name;
	...
	...
	}    
	Pet p1 = new Pet(); 					// Runs with no problems 
	
------------------------------------------------------------------------------------------------------------------------------------------------

- data-types for `name` `gender` and `sound`
	
	String name;
	String gender;
	String sound;  				// A class that has these attributes is fine. However, if all the types are Strings, this opens up the possibility of
								// these variables being set to anything(In String form). It might be worth using Enums or Classes to control the possibilities 
								// of what these variables can be set to. 
									
	Class Gender{}
	Class Male extends Gender{}
	Class Female extends Gender{}
	Class NonBinary extends Gender{}  // One possibility is to create a super class of Gender which has subclasses. This way, you could use 'Gender aGender' in
									  // the class above and create a 'Gender' like Gender m = new Male(); and assign it to Gender eg. Person.setGender(m);
											
	public enum Gender{
		MALE, FEMALE, NONBINARY;
	}								// Enums could also be used by declaring set Genders and assigning them in the class eg.  Gender m = Gender.MALE;
	
----------------------------------------------------------------------------------------------------------------------------------------------------

- `Pet(...)` constructor options for client programmers

Pet(String name, String gender, String sound) {			// This constructor will work fine but it as it is the sole constructor this means there is no		
        this.name = name;								// default constructor for this class. It is sometimes useful to create a 'no-args' constructor in
        this.gender = gender;							// a super class so that sub-classes can be created without having to create their own 'no-args' constructor
        this.sound = sound;
    }
	
	Pet(String name){
		this.name = name; } 							// It might be also useful to create variations of constructors for a class so that the client has options
														// on how many variables to set on creation of a 'Pet'
	Pet(String gender){
		this.gender = gender; }
														
--------------------------------------------------------------------------------------------------------------------------------------------------------
									
- `abstract String makeSound()` compared to just `String makeSound()` or `void makeSound()`

	asbtract String makeSound(); 			// Abstract methods can not have method bodies. Abtract methods must be
											// inherited and given functionality by a subclass. 
											
	public String makeSound(){
		
		return "Roar"; }					// Without the 'abstract' keyword, methods can have method bodies and functionality
											// This method returns a String 
											
	public void makeSound(){
		System.out.println("Roar"); } 		// whereas this method has a return type of 'void' which means nothing is returned. 
											// void methods can be used to print to the screen or set a variable type instead of returning a variable.
											
--------------------------------------------------------------------------------------------------------------------------------------------------------------

- Adding attribute `FoodThing food` with the introduction of `class FoodThing` from which `Bone` and `Fish` are derived.

											
	class FoodThing{						// As each 'Pet' has an attribute of either a 'Bone' or a 'Fish', it might make sense to create a class called
											// FoodThing from which both these attributes extend as subclasses. This generally makes the code easier to read
											// as each Pet now has it's own 'FoodThing' which can be either a Fish or Bone.
	}										// Extra Food Things can then be easily added to the FoodThing super class. This is a form of encapsulation and keeps 
											// code cleaner.
											
	class Bone extends FoodThing{}			// More attributes can then be given to bone as it now has it's own class
	
	class Fish extends FoodThing{}
		
	class Cat{
	
		FoodThing food = new Bone(); 
		
		FoodThing getFood(){				// A general getFood method is now easy to re-use within each 'Pet' sub-class and makes for cleaner code
			return food;
		}									// Also allows for easier crossover of types eg.Dog could have Fish and Cat could have Bone

------------------------------------------------------------------------------------------------------------------------------------------------------------------

- `Bone bone;` with line `bone = new Bone();` (inside Dog(...) as compared to `Bone bone = new Bone();`

	Bone bone;								// Is known as a lazy loading of a variable. Variable is usually instantiated later on in the code, possibly in a constructor
	
	Bone bone = new Bone();					// is know as eager loading of a variable. Assigment of variable is done when class is loaded for the first time.
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------

- `Dog(...)` constructor options for client programmers
	
	Dog(){
	name = "no-name";										// Having a no-args constructor for the Dog class would provide quick and easy setting of  
	gender = "NA";											// default-values for every Dog instance created.
	sound = "...";
	
	Dog(String name, String gender, String sound){			// Because the Dog superclass(Pet) provides a constructor that takes these parameters, the super() call
		super(name, gender, sound); }						// can be used to call the Pet constructor and pass in the given parameters. This is a great examples of code 
															// re-use and keep code clean and very readable.
	
	Dog(String aName){										// It could also be useful to make individual variations of constructors in order for client ease of use of 
		name = aName;										// the Dog class. This would set one variable to a preferred value and the other variables to a possible 
		gender = "NA";										// default value.
		sound = "..."; }													
	
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
- `super(name, gender, "Woof");`

	Dog(String name, String gender) {						// While this constructor covers two of the three instance variables, it would be good to have
        super(name, gender, "Woof");						// variation for ease-of-use. This constructor will automatically set the inherited Dog 'sound' to "Woof"
        bone = new Bone();	}								// which doesn't leave room for the possibility of the Dog sound needing to be "Bark", for example.
															// This form on constructor chaining is necessary when dealing with inheritance between two classes. 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- `getBone()` as compared with making attribute `Dog.bone` accessible for direct access

	 Bone getBone() {										// The reason for using a method called 'getBone' as opposed to accessing an instance variable through an 	
        return bone;										// object eg. 'Dog.bone', is because giving this access to a client using this class can lead to potential 
    }														// problems. An example of this would be if the 'bone' variable had to change it's name or type, this could be 	
															// easily dealt with be changing the code of the 'Getter' and not affecting the client code at all. 
	Bone getBone(){											// Taking these steps and providing 'getters' and 'setters' is a form of encapsulation and overall provides safer
		System.out.println("Retreiving bone!");				// and more organised code. 
		return bone;	}									// There is also the additional possibility to add extra code in order to do something
															// when the client call the 'getter'.
															
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- worthy of a class? if so why?

	class Bone {											// Because the Bone(and Fish) classes are so small, it doesn't seem completely necessary to create seperate classes
		String printString = "$==$";						// for each of them. As these classes seem to function as data containers attached to a form of Pet class, it could make
															// more sense to treat them as such and the introduction of classes may overcomplicate the code.
		public String toString() {
			return printString;
		} }
	
	class Bone {											// A reason for giving Bone it's own class is that it would be easier to update and attributes and give it more detail.
		String printString = "$==$";						// The development and separation of this class will increase the modularity of the overall program. Bone and Fish having
		String size;										// their own class means that they both encapsulate their own behaviours and potential future-added behaviours. These concepts
		int weight;											// of modularity and encapsulation promote the overall reusability of the code.  
		...}								
													
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

- attribute `printString` - worth having this or not?

	class PersonWithAPet { ...								// In the code provided there doesn't seem to be a reason for the Bone and Fish to have a toString override that prints their
															// 'printString' variables. When a 'PersonWithAPet' is printed, we can see there is a toString that prints a statment that shows
	public String toString() {								// person's pet. In order to access the PersonWithAPet/Dog/Bone for example, this would require a more in-depth toString return 
		return "Person's Pet: " + pet.toString(); }	}		// for the person object.
       
	Cat cat = new Cat("Whiskers", "Female");				// If, for instance you wanted to print the Cat/Fish's printString, this would require printing 'cat.fish', which doesn't make 
    Dog dog = new Dog("Buddy", "Male");						// much sense as the client would have to know that the Cat has a Fish. If, on the other hand, the Bone and Fish were part of a
	System.out.println(cat.fish);							// 'FoodThing' class, we could print cat.FoodThing in order to return the String that indicates to the client what 'FoodThing' the
	System.out.println(dog.FoodThing)						// Cat(or Pet) has. This scenario is the only reason I can see when the printString variable would be necessary.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
 
- Include any other points of your choosing

	abstract class Person{									// I think in order to leave this code open to futher improvement, an abstract 'Person' class would be essential. Not only is the 'PersonWithAPet'
															// class too specific, but it doesn't leave much room for improvement. Creating a Person class to which the PersonWithAPet class 
		String name;										// is a subclass works better for modularity and encapsulation. A person can have it's own details and a PersonWithAPet can further 
		int age;											// elaborate on these details by adding a Pet and overriding the showDetails method to include the Pet.
		double height;
		
		Person(String aName, int anAge, double aHeight){
			...}
		
		abstract String getInfo();
		
		
	
	
															// I believe this code is very readable, and easy to expand on by any future users. I expect that if this code was to be made more		
															// intricate it would require seperate files for each class and a Tester class to run operations and see if everything works together.
															// Possible improvements could be variations on constructors with every class, along with the added 'FoodThing' class.
															// I see this code as being a good template for building OO code structures.
															
															